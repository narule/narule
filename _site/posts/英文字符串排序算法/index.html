<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet">
<!--<link href="https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,700&display=swap" rel="stylesheet">-->
<link rel="stylesheet" href="/assets/css/style.css">
<title>英文字符串排序算法</title>
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>英文字符串排序算法 | narule.github.io</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="英文字符串排序算法" />
<meta name="author" content="Narule" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="关于如何排序的思考 编程工作偶尔会遇到一些不常见问题需要处理，学编程处理问题也难免需要熟悉一些算法 以前学习的时候就遇到过一个看似简单的排序算法问题，当时的解决办法是我没有用过的，在此记录一下" />
<meta property="og:description" content="关于如何排序的思考 编程工作偶尔会遇到一些不常见问题需要处理，学编程处理问题也难免需要熟悉一些算法 以前学习的时候就遇到过一个看似简单的排序算法问题，当时的解决办法是我没有用过的，在此记录一下" />
<meta property="og:site_name" content="narule.github.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-05-08T00:00:00+00:00" />
<script type="application/ld+json">
{"description":"关于如何排序的思考 编程工作偶尔会遇到一些不常见问题需要处理，学编程处理问题也难免需要熟悉一些算法 以前学习的时候就遇到过一个看似简单的排序算法问题，当时的解决办法是我没有用过的，在此记录一下","url":"/posts/%E8%8B%B1%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","@type":"BlogPosting","headline":"英文字符串排序算法","dateModified":"2020-05-08T00:00:00+00:00","datePublished":"2020-05-08T00:00:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E8%8B%B1%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},"author":{"@type":"Person","name":"Narule"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="texture-blue">
    <div class="container"><div class="navbar">
	<ul>
		
		<a href="/"><li  >Home</li></a>
		
	</ul>
</div></div><div class="container">
	<h1>英文字符串排序算法</h1>
	<h4 class="post-description"></h4>
	<div class="post-date" style="margin-top:20px">
		Published on May 8, 2020
	</div>
	<ul class="post-tags"></ul>
</div>
</header>
  <main>
    <div class="container">
      <div class="post-container">
          <p>关于如何排序的思考</p>

<blockquote>
  <p>编程工作偶尔会遇到一些不常见问题需要处理，学编程处理问题也难免需要熟悉一些算法</p>

  <p>以前学习的时候就遇到过一个看似简单的排序算法问题，当时的解决办法是我没有用过的，在此记录一下’’</p>
</blockquote>

<h1 id="问题---英文字符串排序">问题 - 英文字符串排序</h1>

<p>如下几个英文单词或者字母</p>

<p>apple，car， a，family，sky，application，app，baby，back，background，bad，bbbbb，bee，cafe ，cake，care</p>

<p>排序后的结果是</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
a
app
apple
application

baby
back
background
bad
bbbbb
bee
cafe 
cake
car
care
family
sky

**/</span>
</code></pre></div></div>

<h2 id="规则逻辑">规则逻辑</h2>

<p>通过结果可知</p>

<p>a 与 app a排前面  （开头字母相同，短的排在前面）</p>

<p>back 与 backgroud back排在前面 （开头字母相同，短的排在前面）</p>

<p>application 与 baby application 排在前面（开头字母不同，从a-z依次排序）</p>

<h2 id="设计实现">设计实现</h2>

<p>a=1 	b=2 	c=3 	d=4 	e=5 	f=6 	g=7 	h=8 	i=9 	j=10</p>

<p>k=11 	l=12 	m=13 	n=14 	o=15 	p=16 	q=17 	r=18 	s=19 	t=20</p>

<p>u=21 	v=22 	w=23 	x=24 	y=25 	z=26</p>

<p>a代表的是 1</p>

<p>b代表的是 2</p>

<p>z 代表 26 就可以实现初步排序</p>

<p>但是 bbbbb与 bee 两个单词要实现 apple 在前，逻辑该怎么写呢</p>

<p>起初想法是，字母依次比较，<code class="language-plaintext highlighter-rouge">bbbbb</code> 与 <code class="language-plaintext highlighter-rouge">bee</code>比较的第二个字母的时候， <code class="language-plaintext highlighter-rouge">b</code> 与 <code class="language-plaintext highlighter-rouge">e</code>  分别代表 2 和 5 所以bbbbb排前面，问题是一个一个字母比较看起来很麻烦，10个单词，10个都要比较</p>

<p>有以下解决方案</p>

<h3 id="方法一-通过单词获取权重进行排序当初使用方法">方法一 通过单词获取权重进行排序（当初使用方法）</h3>

<p>​	<code class="language-plaintext highlighter-rouge">bbbbb</code> =&gt;  b =2 b=2   b=2  b=2   b=2</p>

<p>​	<code class="language-plaintext highlighter-rouge">bee</code> =&gt; b = 2 e =5 e = 5</p>

<p>权重数 Px</p>

<p>Px(bbbbb) = 2 + 2 * 27^-1 + 2 * 27^-2 + 2 * 27^-3 + 2 * 27^-4 = 2.079</p>

<p>Px(bee) = 2 + 5 * 27^-1 + 5 * 27^-2 = 2.192</p>

<p>通过这个计算方式可以获得权重值</p>

<p>Px(bbbbb) &lt; Px(bee)</p>

<p>所以 bbbbb  排在 baby 前面</p>

<h4 id="权重数27">权重数27</h4>

<p>这里为什么是 27 不是26 是考虑到一种情况，会导致排序失败</p>

<p>比如 az  与 b比较</p>

<p>Px(az) = 1 + 26 * 26^-1 = 2</p>

<p>Px(b) = 2</p>

<p>Px(az)  = Px(b) 显然是错的 将26 改为 27 就可避免这个错误</p>

<h4 id="优点">优点</h4>

<p>不管是任何单词，一千个也好，得出每个字符串对应的权重值，就能做到排序</p>

<h4 id="缺点">缺点</h4>

<p>考虑到前一种算法的计算，如果单词长度超过20或者更长，会导致计算量很大的问题</p>

<p>如果有一百个单词，比较计算很有必要，如果只有两个单词</p>

<p>bbbbbbbbbbbbbbbb 与 bar 比较 用权重法不合适，因为只有两个单词没比较计算这么多，就能得出排序结论，下面就讲讲另一种排序算法</p>

<h3 id="方法二-逐个字母计算排序用到递归">方法二 逐个字母计算排序(用到递归)</h3>

<p>下面说一下新思路，逐个比较</p>

<p>apple，car， a，family，sky，application，app，baby，back，background，bad，bbbbb，bee，cafe ，cake，care</p>

<p>还是上面的单词</p>

<ol>
  <li>首先获取每个字符串的第一个字母</li>
</ol>

<p>第一个字母为 a 的 全部取出</p>

<p>apple  a  application app</p>

<p>比较他们的第二个字母 a 没有第二个字母，自然排在最前面，依次类推，使用递归即可完成排序</p>

<p>因为临时想到的一种排序方法，用到了TreeSet HashMap ArrayList 工具类，感觉还可以后期优化。</p>

<p>代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">package</span> <span class="nn">javabasis.algorithm</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">java.util.ArrayList</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.List</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.Set</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">java.util.TreeMap</span><span class="o">;</span>

<span class="cm">/**
 * 字段排序算法
 * 
 * @author Narule
 *
 */</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">StringAlgorithm</span> <span class="o">{</span>

	<span class="cm">/**
	 * 逐个字母比较排序
	 * 
	 * @param disorder
	 * @return orderly
	 */</span>
	<span class="kd">public</span> <span class="kd">static</span> <span class="nc">String</span><span class="o">[]</span> <span class="nf">nopTop</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">disorder</span><span class="o">)</span> <span class="o">{</span>
		<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">disorder</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>
		<span class="nc">String</span><span class="o">[]</span> <span class="n">orderly</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">end</span><span class="o">];</span> <span class="c1">// 新建排序后的数组</span>
		<span class="nc">TreeMap</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;&gt;</span> <span class="n">treeMap</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">TreeMap</span><span class="o">&lt;&gt;();</span> <span class="c1">// 排序工具类，key是按照大小排序的</span>
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>

		<span class="c1">// 收集字符串首字母信息</span>
		<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">str</span> <span class="o">:</span> <span class="n">disorder</span><span class="o">)</span> <span class="o">{</span>
			<span class="kt">char</span> <span class="n">cTag</span> <span class="o">=</span> <span class="n">str</span><span class="o">.</span><span class="na">charAt</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>

			<span class="n">list</span> <span class="o">=</span> <span class="n">treeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">cTag</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">list</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
				<span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="mi">1</span><span class="o">);</span>
			<span class="o">}</span>
			<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">str</span><span class="o">);</span>
			<span class="n">treeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">cTag</span><span class="o">,</span> <span class="n">list</span><span class="o">);</span>
		<span class="o">}</span>

		<span class="c1">// 通过收集的首字母信息给字符串排序</span>
		<span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Character</span><span class="o">&gt;</span> <span class="n">keySet</span> <span class="o">=</span> <span class="n">treeMap</span><span class="o">.</span><span class="na">keySet</span><span class="o">();</span>
		<span class="k">for</span> <span class="o">(</span><span class="kt">char</span> <span class="n">cTag</span> <span class="o">:</span> <span class="n">keySet</span><span class="o">)</span> <span class="o">{</span>
			<span class="n">list</span> <span class="o">=</span> <span class="n">treeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">cTag</span><span class="o">);</span>
			<span class="k">if</span> <span class="o">(</span><span class="n">list</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>

				<span class="k">if</span> <span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 如果只有一个字符串，不需要递归</span>
					<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">string</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
						<span class="n">orderly</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">string</span><span class="o">;</span>
						<span class="n">index</span><span class="o">++;</span>
					<span class="o">}</span>
				<span class="o">}</span> <span class="k">else</span> <span class="o">{</span> <span class="c1">// 如果有两个以上字符串，开头字母相同，可能需要递归排序</span>
					<span class="nc">ArrayList</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">arrayList</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;(</span><span class="mi">0</span><span class="o">);</span>
					<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">string</span> <span class="o">:</span> <span class="n">list</span><span class="o">)</span> <span class="o">{</span>
						<span class="k">if</span> <span class="o">(</span><span class="n">string</span><span class="o">.</span><span class="na">length</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span> <span class="c1">// 字符串长度大于2的，需要添加到list,准备下一次递归排序用到</span>
							<span class="n">arrayList</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">string</span><span class="o">.</span><span class="na">substring</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
						<span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
							<span class="n">orderly</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">string</span><span class="o">;</span>
							<span class="n">index</span><span class="o">++;</span>
						<span class="o">}</span>
					<span class="o">}</span>
					<span class="k">if</span> <span class="o">(</span><span class="n">arrayList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
						<span class="nc">String</span><span class="o">[]</span> <span class="n">array</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">[</span><span class="n">arrayList</span><span class="o">.</span><span class="na">size</span><span class="o">()];</span>
						<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
						<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">string</span> <span class="o">:</span> <span class="n">arrayList</span><span class="o">)</span> <span class="o">{</span>
							<span class="n">array</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">string</span><span class="o">;</span>
							<span class="n">i</span><span class="o">++;</span>
						<span class="o">}</span>
						<span class="n">array</span> <span class="o">=</span> <span class="n">nopTop</span><span class="o">(</span><span class="n">array</span><span class="o">);</span> <span class="c1">// 还需要递归排序 back background -&gt; ack ackground</span>
						<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">string</span> <span class="o">:</span> <span class="n">array</span><span class="o">)</span> <span class="o">{</span>
							<span class="n">orderly</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">cTag</span> <span class="o">+</span> <span class="n">string</span><span class="o">;</span>
							<span class="n">index</span><span class="o">++;</span>
						<span class="o">}</span>
					<span class="o">}</span> <span class="k">else</span> <span class="k">if</span> <span class="o">(</span><span class="n">arrayList</span><span class="o">.</span><span class="na">size</span><span class="o">()</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
						<span class="n">orderly</span><span class="o">[</span><span class="n">index</span><span class="o">]</span> <span class="o">=</span> <span class="n">cTag</span> <span class="o">+</span> <span class="n">arrayList</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
						<span class="n">index</span><span class="o">++;</span>
					<span class="o">}</span>
				<span class="o">}</span>
			<span class="o">}</span>

		<span class="o">}</span>
		<span class="n">treeMap</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
		<span class="k">return</span> <span class="n">orderly</span><span class="o">;</span> <span class="c1">// 排序后的字符串数组</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">String</span><span class="o">[]</span> <span class="n">noP</span> <span class="o">=</span> <span class="o">{</span> <span class="s">"apple"</span><span class="o">,</span> <span class="s">"car"</span><span class="o">,</span> <span class="s">"a"</span><span class="o">,</span> <span class="s">"family"</span><span class="o">,</span> <span class="s">"sky"</span><span class="o">,</span> <span class="s">"application"</span><span class="o">,</span> <span class="s">"app"</span><span class="o">,</span> <span class="s">"baby"</span><span class="o">,</span> <span class="s">"back"</span><span class="o">,</span> <span class="s">"background"</span><span class="o">,</span>
				<span class="s">"bad"</span><span class="o">,</span> <span class="s">"bbbbb"</span><span class="o">,</span> <span class="s">"bee"</span><span class="o">,</span> <span class="s">"cafe"</span><span class="o">,</span> <span class="s">"cake"</span><span class="o">,</span> <span class="s">"care"</span> <span class="o">};</span>
		<span class="nc">String</span><span class="o">[]</span> <span class="n">nopTop</span> <span class="o">=</span> <span class="n">nopTop</span><span class="o">(</span><span class="n">noP</span><span class="o">);</span>
		<span class="k">for</span> <span class="o">(</span><span class="nc">String</span> <span class="n">string</span> <span class="o">:</span> <span class="n">nopTop</span><span class="o">)</span> <span class="o">{</span>
			<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">string</span><span class="o">);</span>
		<span class="o">}</span>

	<span class="o">}</span>
<span class="o">}</span>

</code></pre></div></div>

<p>此方法用到TreeMap,这是Java工具类，自带排序效果，对此有疑问可以查看java源代码，或介绍文档</p>

<h4 id="优点-1">优点</h4>

<p>没有很大的计算量</p>

<h4 id="缺点-1">缺点</h4>

<p>使用TreeMap ArrayList 对象，递归过多也会出现内存损耗过大或者溢出的情况</p>

<p>未完，后期待优化</p>

      </div>

        <!-- Configure Disqus --></div>
  </main></body>
</html>