<!DOCTYPE html>
<html lang="en">
<head><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<link href="https://fonts.googleapis.com/css?family=Open+Sans:400,700" rel="stylesheet">
<!--<link href="https://fonts.googleapis.com/css?family=Nunito+Sans:400,400i,700&display=swap" rel="stylesheet">-->
<link rel="stylesheet" href="/assets/css/style.css">
<title>分布式事务</title>
<!-- Begin Jekyll SEO tag v2.6.1 -->
<title>分布式事务 | narule.github.io</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="分布式事务" />
<meta name="author" content="Narule" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="关于分布式的思考 分布式事务 分布式环境下的事务 要了解分布式事务，首先要了解分布式环境" />
<meta property="og:description" content="关于分布式的思考 分布式事务 分布式环境下的事务 要了解分布式事务，首先要了解分布式环境" />
<meta property="og:site_name" content="narule.github.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-06-12T23:33:36+08:00" />
<script type="application/ld+json">
{"description":"关于分布式的思考 分布式事务 分布式环境下的事务 要了解分布式事务，首先要了解分布式环境","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"},"@type":"BlogPosting","url":"/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/","headline":"分布式事务","dateModified":"2020-06-12T23:33:36+08:00","datePublished":"2020-06-12T23:33:36+08:00","author":{"@type":"Person","name":"Narule"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
  <header class="texture-blue">
    <div class="container"><div class="navbar">
	<ul>
		
		<a href="/home"><li  >Home</li></a>
		
	</ul>
</div></div><div class="container">
	<h1>分布式事务</h1>
	<h4 class="post-description"></h4>
	<div class="post-date" style="margin-top:20px">
		Published on Jun 12, 2020
	</div>
	<ul class="post-tags"></ul>
</div>
</header>
  <main>
    <div class="container">
      <div class="post-container">
          <p>关于分布式的思考</p>

<h1 id="分布式事务">分布式事务</h1>

<p>分布式环境下的事务</p>

<p>要了解分布式事务，首先要了解分布式环境’’</p>

<h2 id="分布式">分布式</h2>

<p>如一网站，访问一个服务A（查询自己用户信息）， 提供服务A的服务器分别有A1（上海）A2（广州） A3（新加坡）</p>

<p>同一个服务分布在三个区域的服务器上，这就是分布式。你可以访问 上海的服务器，广州的或者新加坡的，但是</p>

<p>三个服务器之前通信是有延迟的，所以数据同步需要一定时间</p>

<p><img src="E:\data\pricture\访问分布式服务.png" alt="" /></p>

<h3 id="分布式中的问题">分布式中的问题</h3>

<p>举例一个分布式场景</p>

<p>如果用户Y个人信息 名字为 “南柯一梦” Y改为 “南柯梦”， 同一时间，Y用户好友查看Y的名字，好友查询的结果是”南柯一梦” 还是 “南柯梦”  这是分布式系统常见的问题（数据修改发生在上海，访问发生在新加坡）。</p>

<h2 id="cap原则">CAP原则</h2>

<blockquote>
  <p>CAP原则又称CAP定理，指的是在一个分布式系统中，一致性（Consistency）、可用性（Availability）、分区容错性（Partition tolerance）。CAP 原则指的是，这三个要素最多只能同时实现两点，不可能三者兼顾。</p>
</blockquote>

<p>以为网络有延迟和不可测故障，因此分布式系统是保持服务稳定的常用手段，但是分布式因为服务机器分布在不同地点，因此也会有分布式的特点问题。</p>

<p>分布式中 一致性 可用性 容灾性 是三个指标</p>

<h3 id="consistency">Consistency</h3>

<p>数据一致性，分布式环境下，不同地点的服务器，数据库数据同步一致。</p>

<h3 id="availability">Availability</h3>

<p>服务可用性，分布式环境下，调用服务，都可用</p>

<h3 id="partition-tolerance">Partition tolerance</h3>

<p>分区容错性，容灾能力</p>

<p>分布式环境多台服务器运行，其中一部分机器故障了，整个系统仍然可以正常运行提供服务</p>

<h3 id="cap不能同时满足">CAP不能同时满足</h3>

<p><strong>必须满足P</strong></p>

<p>首先分布式环境，系统需要稳定运行，一台服务器意外断电，不应该影响系统整体功能正常，另一台或多台服务器还能稳定提供服务，所以分区容错是必须要满足。</p>

<p><strong>满足C</strong></p>

<p>数据一致性，所指的是同一个服务所在不同服务器的数据是同步的。如上改名字的场景 南柯一梦 改为 南柯梦 （在上海的数据库被修改） 那么系统要做到满足数据一致性，必须马上同步广州和新加坡的数据库，这样才能满足广州或者新加坡的访问者获得的结果也一致是 “南柯梦” 而不是”南柯一梦”</p>

<p><strong>满足A</strong></p>

<p>服务可用性，指任何时候访问服务，都返回结果</p>

<p>A与C是冲突的，上海服务器南柯一梦改为南柯梦后，为了服务可用，此时间访问新加坡和广州的服务器，返回的结果应该是南柯一梦(任何时候服务都返回结果) 但是严格上讲，数据是错误的，因为用户已经改了名字，改为南柯梦，但是数据在上海的才是正确的。</p>

<p><strong>满足数据一致性必须牺牲服务可用性 或者相反</strong></p>

<p>要达到数据一致性的要求，必须在上海服务器修改数据的同时，同步广州和新加坡的数据库，并且在数据同步完成之前，访问广州和新加坡的数据库中这条数据需要等待，返回同步后的结果（一致性）。</p>

<p>失去了服务可用性（这里服务是等待数据同步完成才返回结果，而不是立刻返回）</p>

<p>因此CAP  要么 满足AP （分区服务可用）要么 CP （分区数据一致）</p>

<h2 id="分布式中事务">分布式中事务</h2>

<h3 id="商品购买中的事务">商品购买中的事务</h3>

<p>以商品购买生成订单为例子</p>

<font color="red">网络上用户A 购买 一双鞋子 价格50 付款后生成消费订单</font>

<h4 id="事务中包含子的服务">事务中包含子的服务</h4>

<p>这里简单设为三个服务，他们是事务相关的</p>

<p><strong>1.商品信息服务</strong></p>

<p>提供商品信息等服务</p>

<p>鞋子 颜色 价格 库存数量等信息 这里设 价格price为 50 库存数 num 9</p>

<p><strong>2.商家账号收款服务</strong></p>

<p>提供金额收入信息等服务</p>

<p>用户购买鞋子，需要付款50元到商家账号</p>

<p><strong>3.用户消费订单服务</strong></p>

<p>提供购买消费凭证信息等服务</p>

<p>首先分析用户购买鞋子，三个服务分别要做什么</p>

<p>@1 鞋子库存减1</p>

<p>@2 商家账号金额增加50</p>

<p>@3 生成 用户购买鞋子的订单记录， 包括数量金额等信息</p>

<h4 id="事务特性">事务特性</h4>

<p><strong>原子性</strong></p>

<p>@1 @2 @3 要么同时发生，要么都不发生</p>

<p><strong>一致性</strong></p>

<p>鞋子库存减少1，收入增加50</p>

<p><strong>隔离性</strong></p>

<p>鞋子库存减1，后续用户最多只能购买(9-1=8)双鞋子</p>

<p><strong>持久性</strong></p>

<p>动作执行成功后，订单生效，收入新增50生效，库存减1生效</p>

<p><img src="E:\data\pricture\分布式事务.png" alt="" /></p>

<p>上述三个服务他们可以在不同的地点，不同机器上部署的，并很常见。</p>

<h4 id="保证数据正确">保证数据正确</h4>

<p><strong>开启事务</strong></p>

<p>确定要执行的服务，每个服务的数据库事务开启</p>

<p><strong>执行业务</strong></p>

<p>调用库存减1，转账，生成订单等子服务</p>

<p><strong>提交</strong></p>

<p>业务执行过程中没有意外，各子服务的数据库提交事务，生效数据修改</p>

<p><strong>回退</strong></p>

<p>回退，如果服务调用出现了差错，或者某个子服务执行失败，可以通过回滚所有数据库达到数据正确。</p>

<p><strong>补偿</strong></p>

<p>某些情况下，某个子服务执行失败，但是不影响整体业务，也可以提交事务，后续补偿机制将失败的子服务重新执行。</p>

<h4 id="补偿机制">补偿机制</h4>

<p>个人认为就商品购买而言，补偿机制多数情况可以使用且实用。（对强一致要求没那么高的情况下）</p>

<p>@1 库存减1</p>

<p>@2 收入增加50</p>

<p>@ 3生成订单记录</p>

<p>如果这次执行的动作， 只有@3失败，@1 @2成功 说明金额交易，商品库存业务都没问题，只是订单记录失败，这是可以提交事务的，订单错误可以生成一条记录（携带商品，金额等信息），发送到MQ消息队列（或者其他设计）通过消息队列通知订单相关服务，补偿重新执行生成订单，达到最终一致性。</p>

<h3 id="分布式事务控制问题">分布式事务控制问题</h3>

<h4 id="不同服务在不同区运行">不同服务在不同区运行</h4>

<p>不管是从安全性，稳定性，还是服务粒度细化方便维护等多因素考虑，都是很有必要让不同的服务分开在不同服务区运行。</p>

<p>单体数据库的事务不被支持，购买商品到生成订单所有操作加起来算一个事务，涉及的数据在不同一服务（不同的数据库），并且同一个服务可能运行在多台服务器上。</p>

<p>数据库开启事务针对的是单台服务器，多个服务多个数据库，并不支持数据库的事务，需要额外设计处理数据一致性问题（或者最终一致性）</p>

<h4 id="同一个服务运行在多个区">同一个服务运行在多个区</h4>

<p>不同服务不在一个服务器，同样的，分布式为稳定性可用而生，因此，一个服务大多有在多个区的服务器上运行，开启事务的时候，如何保证事务开启提交等事务相关命令每次发送到同一个区的同一个服务器，也是一定要考虑的问题。</p>

<h3 id="分布式事务处理方式">分布式事务处理方式</h3>

<p>如上所述分布式服务代表多个数据库，不支持数据库的事务，</p>

<p>如何保证事务中涉及的数据库数据修改都提交生效或者都回滚。</p>

<h4 id="建立控制中心">建立控制中心</h4>

<p>控制中心在执行业务时，统一发送开始事务的命令给三个服务，返回状态</p>

<p>状态没问题执行数据修改，</p>

<p>都没问题就发送给三个服务，提交事务，否在回滚事务</p>

<h4 id="消息机制事务">消息机制事务</h4>

<p>MQ消息队列，达到控制事务正确目的，项目中kafka听的比较多，可在高并发环境下稳定运行，可以通过消息机制发送事务处理结果到子服务，子服务收到消息，通过分析消息内容，做出对应的操作，达到事务一致性或者最终一致性等目的</p>

<p>通过消息队列控制分布式事务支持</p>

<p>思考图：</p>

<p><img src="E:\data\pricture\分布式事务消息队列维护事务.png" alt="" /></p>

      </div>

        <!-- Configure Disqus --></div>
  </main></body>
</html>